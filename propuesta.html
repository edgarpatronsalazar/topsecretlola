<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>üíñ</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body {
    width: 100%; height: 100%;
    overflow: hidden;
    background: #1a0a2e;
    font-family: 'Segoe UI', Arial, sans-serif;
    touch-action: none;
    user-select: none;
    -webkit-user-select: none;
  }

  /* Pantalla de orientaci√≥n */
  #rotate-screen {
    display: none;
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: #1a0a2e;
    z-index: 9999;
    flex-direction: column;
    align-items: center; justify-content: center;
    color: #ffb6c1; font-size: 1.5em; text-align: center;
  }
  #rotate-screen .rotate-icon {
    font-size: 4em; margin-bottom: 20px;
    animation: rotateAnim 2s ease-in-out infinite;
  }
  @keyframes rotateAnim {
    0%, 100% { transform: rotate(0deg); }
    50% { transform: rotate(90deg); }
  }

  /* Canvas del juego */
  #gameCanvas {
    display: block;
    width: 100%; height: 100%;
    background: #1a0a2e;
  }

  /* Controles t√°ctiles */
  #touch-controls {
    position: fixed; bottom: 0; left: 0; width: 100%; height: 120px;
    display: flex; justify-content: space-between; align-items: center;
    padding: 0 20px; pointer-events: none; z-index: 10;
  }
  .ctrl-group {
    display: flex; gap: 10px; pointer-events: auto;
  }
  .ctrl-btn {
    width: 70px; height: 70px;
    border-radius: 50%;
    background: rgba(255, 182, 193, 0.25);
    border: 2px solid rgba(255, 182, 193, 0.5);
    color: #ffb6c1;
    font-size: 28px;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;
    transition: background 0.1s;
  }
  .ctrl-btn:active, .ctrl-btn.active {
    background: rgba(255, 182, 193, 0.5);
  }
  .ctrl-btn-jump {
    width: 80px; height: 80px;
    font-size: 20px;
  }

  /* HUD */
  #hud {
    position: fixed; top: 10px; left: 0; width: 100%;
    display: flex; justify-content: center; gap: 30px;
    z-index: 10; pointer-events: none;
  }
  .hud-item {
    background: rgba(0,0,0,0.4);
    padding: 6px 16px;
    border-radius: 20px;
    color: #fff;
    font-size: 1.1em;
    border: 1px solid rgba(255,182,193,0.3);
  }

  /* Pantalla de propuesta */
  #proposal-screen {
    display: none;
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(26, 10, 46, 0.95);
    z-index: 100;
    flex-direction: column;
    align-items: center; justify-content: center;
    animation: fadeIn 1s ease;
  }
  @keyframes fadeIn {
    from { opacity: 0; } to { opacity: 1; }
  }
  #proposal-screen h1 {
    color: #ffb6c1; font-size: 2em; text-align: center;
    margin-bottom: 30px; padding: 0 20px;
    text-shadow: 0 0 20px rgba(255,105,180,0.5);
  }
  .proposal-buttons {
    display: flex; gap: 20px;
  }
  .proposal-btn {
    padding: 15px 50px;
    font-size: 1.4em;
    border: none; border-radius: 30px;
    cursor: pointer;
    font-weight: bold;
    transition: transform 0.2s, box-shadow 0.2s;
  }
  .proposal-btn:hover {
    transform: scale(1.05);
  }
  .btn-si {
    background: linear-gradient(135deg, #ff69b4, #ff1493);
    color: #fff;
    box-shadow: 0 4px 20px rgba(255,105,180,0.5);
  }
  .btn-no {
    background: linear-gradient(135deg, #666, #444);
    color: #ccc;
    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
  }
  .btn-no.hidden {
    visibility: hidden;
    pointer-events: none;
  }

  /* Cat error message */
  #cat-message {
    display: none;
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(26, 10, 46, 0.95);
    z-index: 200;
    flex-direction: column;
    align-items: center; justify-content: center;
    animation: fadeIn 0.5s ease;
  }
  #cat-message .cat-emoji { font-size: 5em; margin-bottom: 20px; }
  #cat-message p {
    color: #ffb6c1; font-size: 1.5em; text-align: center;
    padding: 0 30px; max-width: 600px;
  }

  /* Success screen */
  #success-screen {
    display: none;
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: #1a0a2e;
    z-index: 300;
    flex-direction: column;
    align-items: center; justify-content: center;
    animation: fadeIn 1s ease;
  }
  #success-canvas {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 301;
  }
  #success-text {
    position: absolute;
    top: 8%;
    width: 100%;
    text-align: center;
    z-index: 302;
    pointer-events: none;
  }
  #success-text h1 {
    color: #ff69b4; font-size: 2em;
    text-shadow: 0 0 30px rgba(255,105,180,0.6);
    padding: 0 20px; line-height: 1.5;
    animation: pulse 1.5s ease-in-out infinite;
  }

  /* Floating hearts bg */
  .floating-heart {
    position: fixed;
    color: #ff69b4;
    opacity: 0.3;
    animation: floatUp linear infinite;
    pointer-events: none;
    z-index: 250;
  }
  @keyframes floatUp {
    0% { transform: translateY(100vh) rotate(0deg); opacity: 0.3; }
    100% { transform: translateY(-100px) rotate(360deg); opacity: 0; }
  }

  /* Start screen */
  #start-screen {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: #1a0a2e;
    z-index: 50;
    display: flex; flex-direction: column;
    align-items: center; justify-content: flex-end;
    padding-bottom: 60px;
    cursor: pointer;
  }

  /* Cat dialogue container */
  .dialogue-wrap {
    display: flex;
    flex-direction: column;
    align-items: center;
    position: relative;
  }

  /* Text bubble */
  .text-bubble {
    background: #fff;
    border: 3px solid #5a3e2b;
    border-radius: 16px;
    padding: 18px 24px;
    max-width: 420px;
    min-width: 280px;
    min-height: 80px;
    position: relative;
    margin-bottom: 16px;
    box-shadow: 0 4px 16px rgba(0,0,0,0.3);
  }
  .text-bubble::after {
    content: '';
    position: absolute;
    bottom: -14px;
    left: 50%;
    transform: translateX(-50%);
    width: 0; height: 0;
    border-left: 14px solid transparent;
    border-right: 14px solid transparent;
    border-top: 14px solid #5a3e2b;
  }
  .text-bubble::before {
    content: '';
    position: absolute;
    bottom: -10px;
    left: 50%;
    transform: translateX(-50%);
    width: 0; height: 0;
    border-left: 11px solid transparent;
    border-right: 11px solid transparent;
    border-top: 11px solid #fff;
    z-index: 1;
  }
  .text-bubble p {
    color: #2a1a0a;
    font-size: 1.15em;
    line-height: 1.5;
    font-family: 'Segoe UI', Arial, sans-serif;
    margin: 0;
  }
  .text-bubble .continue-hint {
    position: absolute;
    bottom: 6px; right: 12px;
    color: #aa8866;
    font-size: 0.8em;
    animation: blink 1.2s ease-in-out infinite;
  }

  /* Cat sprite area */
  .intro-cat {
    width: 140px;
    height: 174px;
    position: relative;
  }
  .intro-cat img {
    width: 100%; height: 100%;
    object-fit: contain;
    position: absolute;
    top: 0; left: 0;
  }
  /* Mouth overlay ‚Äî TAPA la boca abierta del gato (simula boca cerrada) */
  .cat-mouth {
    position: absolute;
    left: 52%;
    top: 47%;
    transform: translateX(-50%);
    width: 20px;
    height: 15px;
    background: #ffffff;
    border-radius: 40%;
    opacity: 1;
    pointer-events: none;
    z-index: 2;
    transition: opacity 0.04s;
  }
  /* Cuando habla: se quita la tapa ‚Üí se ve la boca abierta natural */
  .intro-cat.talking .cat-mouth {
    opacity: 0;
  }

  @keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
  }

  @media (orientation: portrait) {
    #rotate-screen { display: flex !important; }
    #gameCanvas, #touch-controls, #hud, #start-screen { display: none !important; }
  }
</style>
</head>
<body>

<!-- Pantalla de rotar -->
<div id="rotate-screen">
  <div class="rotate-icon">üì±</div>
  <p>Por favor, gira tu tablet<br>en horizontal üîÑ</p>
</div>

<!-- Pantalla de inicio -->
<div id="start-screen">
  <div class="dialogue-wrap">
    <div class="text-bubble">
      <p id="dialogue-text"></p>
      <span class="continue-hint" id="continue-hint" style="display:none">‚ñº Toca</span>
    </div>
    <div class="intro-cat" id="intro-cat">
      <img src="gatofinalfinal.png" alt="gato">
      <div class="cat-mouth"></div>
    </div>
  </div>
</div>

<!-- HUD -->
<div id="hud" style="display:none;">
  <div class="hud-item" id="hud-pizza">üçï 0 / 0</div>
  <div class="hud-item" id="hud-sushi">üç£ 0 / 0</div>
</div>

<!-- Canvas -->
<canvas id="gameCanvas"></canvas>

<!-- Controles t√°ctiles -->
<div id="touch-controls" style="display:none;">
  <div class="ctrl-group">
    <div class="ctrl-btn" id="btn-left">‚óÄ</div>
    <div class="ctrl-btn" id="btn-right">‚ñ∂</div>
  </div>
  <div class="ctrl-group">
    <div class="ctrl-btn ctrl-btn-jump" id="btn-jump">‚ñ≤</div>
  </div>
</div>

<!-- Propuesta -->
<div id="proposal-screen">
  <h1>¬øQuieres ir a una cita conmigo<br>este ¬ø? de Febrero? üíï</h1>
  <div class="proposal-buttons">
    <button class="proposal-btn btn-si" onclick="answerYes()">S√≠ üíñ</button>
    <button class="proposal-btn btn-no" id="btn-no" onclick="answerNo()">No</button>
  </div>
</div>

<!-- Mensaje del gato -->
<div id="cat-message">
  <div class="cat-emoji">üòø</div>
  <p>Creo que no has entendido... preguntar√© de nuevo</p>
</div>

<!-- Pantalla de √©xito -->
<div id="success-screen">
  <canvas id="success-canvas"></canvas>
  <div id="success-text">
    <h1>¬°Genial! Te amo preciosa üíó<br><br>Nos vemos el ¬ø? de Febrero ü•∞<br><span style="font-size:0.5em;opacity:0.7;font-style:italic">* fecha pendiente de aprobaci√≥n</span></h1>
  </div>
</div>

<script>
// ===================== AUDIO (Web Audio API ‚Äî sin archivos externos) =====================
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx;
function ensureAudio() {
  if (!audioCtx) audioCtx = new AudioCtx();
}

function playJump() {
  ensureAudio();
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.connect(g); g.connect(audioCtx.destination);
  o.type = 'sine';
  o.frequency.setValueAtTime(400, audioCtx.currentTime);
  o.frequency.linearRampToValueAtTime(800, audioCtx.currentTime + 0.15);
  g.gain.setValueAtTime(0.15, audioCtx.currentTime);
  g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.15);
  o.start(); o.stop(audioCtx.currentTime + 0.15);
}

function playCollect() {
  ensureAudio();
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.connect(g); g.connect(audioCtx.destination);
  o.type = 'sine';
  o.frequency.setValueAtTime(600, audioCtx.currentTime);
  o.frequency.linearRampToValueAtTime(1200, audioCtx.currentTime + 0.1);
  g.gain.setValueAtTime(0.2, audioCtx.currentTime);
  g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.2);
  o.start(); o.stop(audioCtx.currentTime + 0.2);
  // Second note
  const o2 = audioCtx.createOscillator();
  const g2 = audioCtx.createGain();
  o2.connect(g2); g2.connect(audioCtx.destination);
  o2.type = 'sine';
  o2.frequency.setValueAtTime(900, audioCtx.currentTime + 0.1);
  o2.frequency.linearRampToValueAtTime(1400, audioCtx.currentTime + 0.2);
  g2.gain.setValueAtTime(0.2, audioCtx.currentTime + 0.1);
  g2.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
  o2.start(audioCtx.currentTime + 0.1); o2.stop(audioCtx.currentTime + 0.3);
}

function playWin() {
  ensureAudio();
  const notes = [523, 659, 784, 1047];
  notes.forEach((freq, i) => {
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.connect(g); g.connect(audioCtx.destination);
    o.type = 'sine';
    o.frequency.value = freq;
    g.gain.setValueAtTime(0.15, audioCtx.currentTime + i * 0.15);
    g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + i * 0.15 + 0.3);
    o.start(audioCtx.currentTime + i * 0.15);
    o.stop(audioCtx.currentTime + i * 0.15 + 0.3);
  });
}

function playError() {
  ensureAudio();
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.connect(g); g.connect(audioCtx.destination);
  o.type = 'square';
  o.frequency.setValueAtTime(200, audioCtx.currentTime);
  o.frequency.linearRampToValueAtTime(100, audioCtx.currentTime + 0.3);
  g.gain.setValueAtTime(0.15, audioCtx.currentTime);
  g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.4);
  o.start(); o.stop(audioCtx.currentTime + 0.4);
}

function playYes() {
  ensureAudio();
  const notes = [523, 659, 784, 1047, 1319];
  notes.forEach((freq, i) => {
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.connect(g); g.connect(audioCtx.destination);
    o.type = 'sine';
    o.frequency.value = freq;
    g.gain.setValueAtTime(0.12, audioCtx.currentTime + i * 0.12);
    g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + i * 0.12 + 0.4);
    o.start(audioCtx.currentTime + i * 0.12);
    o.stop(audioCtx.currentTime + i * 0.12 + 0.4);
  });
}

// ===================== GAME STATE =====================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let W, H;
function resizeCanvas() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Camera
let cameraX = 0;

// World dimensions
const WORLD_W = 3200;

// Gravity
const GRAVITY = 0.6;

// Player (cat)
const cat = {
  x: 80, y: 0, w: 40, h: 40,
  vx: 0, vy: 0,
  speed: 4.5,
  jumpForce: -12,
  onGround: false,
  dir: 1, // 1=right, -1=left
  frame: 0,
  frameTimer: 0
};

// Platforms
const platforms = [
  // Ground segments
  { x: 0, y: H - 40, w: 600, h: 40 },
  { x: 700, y: H - 40, w: 400, h: 40 },
  { x: 1200, y: H - 40, w: 500, h: 40 },
  { x: 1800, y: H - 40, w: 400, h: 40 },
  { x: 2300, y: H - 40, w: 900, h: 40 },

  // Floating platforms
  { x: 200, y: H - 140, w: 120, h: 20 },
  { x: 450, y: H - 200, w: 120, h: 20 },
  { x: 650, y: H - 160, w: 100, h: 20 },
  { x: 880, y: H - 220, w: 130, h: 20 },
  { x: 1100, y: H - 160, w: 110, h: 20 },
  { x: 1350, y: H - 240, w: 140, h: 20 },
  { x: 1550, y: H - 170, w: 100, h: 20 },
  { x: 1750, y: H - 130, w: 120, h: 20 },
  { x: 1950, y: H - 200, w: 130, h: 20 },
  { x: 2150, y: H - 260, w: 120, h: 20 },
  { x: 2400, y: H - 180, w: 140, h: 20 },
  { x: 2650, y: H - 240, w: 130, h: 20 },
  { x: 2900, y: H - 160, w: 120, h: 20 },
];

// Collectibles
const collectibles = [
  // Pizzas üçï
  { x: 230, y: H - 180, type: 'pizza', collected: false },
  { x: 490, y: H - 240, type: 'pizza', collected: false },
  { x: 900, y: H - 260, type: 'pizza', collected: false },
  { x: 1370, y: H - 280, type: 'pizza', collected: false },
  { x: 1960, y: H - 240, type: 'pizza', collected: false },
  { x: 2670, y: H - 280, type: 'pizza', collected: false },

  // Sushi üç£
  { x: 670, y: H - 200, type: 'sushi', collected: false },
  { x: 1120, y: H - 200, type: 'sushi', collected: false },
  { x: 1570, y: H - 210, type: 'sushi', collected: false },
  { x: 2170, y: H - 300, type: 'sushi', collected: false },
  { x: 2420, y: H - 220, type: 'sushi', collected: false },
  { x: 2920, y: H - 200, type: 'sushi', collected: false },
];

let totalPizza = collectibles.filter(c => c.type === 'pizza').length;
let totalSushi = collectibles.filter(c => c.type === 'sushi').length;
let collectedPizza = 0;
let collectedSushi = 0;

// Stars (optimized - simple rects, no arc/alpha string)
const stars = [];
for (let i = 0; i < 50; i++) {
  stars.push({ x: Math.random() * 2560, y: Math.random() * 300, s: Math.random() > 0.7 ? 2 : 1, b: Math.random() });
}

// City buildings
const buildings = [];
const PFONT = {
  'T': ['111','010','010','010','010'],
  'E': ['111','100','110','100','111'],
  'A': ['010','101','111','101','101'],
  'M': ['101','111','101','101','101'],
  'O': ['111','101','101','101','111'],
  'L': ['100','100','100','100','111'],
  ' ': ['0','0','0','0','0']
};
function textToGrid(text) {
  const rows = [[],[],[],[],[]];
  for (let i = 0; i < text.length; i++) {
    if (i > 0) for (let r = 0; r < 5; r++) rows[r].push(0);
    const ch = PFONT[text[i]];
    for (let r = 0; r < 5; r++) for (let k = 0; k < ch[r].length; k++) rows[r].push(+ch[r][k]);
  }
  return rows;
}
const msgLine1 = textToGrid('TE AMO');
const msgLine2 = textToGrid('LOLA');

function generateBuildings() {
  buildings.length = 0;
  const groundY = H - 40;
  const shades = ['#151030','#1a1540','#1e1845','#121028','#181340'];
  let bx = 20;
  while (bx < WORLD_W + 200) {
    const w = 50 + Math.random() * 80;
    const h = 60 + Math.random() * (H * 0.5);
    const wCols = Math.floor((w - 12) / 15);
    const wRows = Math.floor((h - 20) / 20);
    const wins = [];
    for (let j = 0; j < wCols * wRows; j++) wins.push(Math.random() > 0.4);
    buildings.push({ x: bx, w, h, y: groundY - h, shade: shades[(Math.random() * shades.length) | 0], wCols, wRows, wins, msg: false });
    bx += w + 15 + Math.random() * 40;
  }
  const maxC = Math.max(msgLine1[0].length, msgLine2[0].length);
  const cs = 14;
  const bw = maxC * cs + 24;
  const bh = 12 * cs + 50;
  buildings.push({ x: 1200, w: bw, h: bh, y: groundY - bh, shade: '#151038', msg: true, cs, maxC });
}

// Pre-rendered emoji sprites (avoid fillText every frame)
let pizzaSprite, sushiSprite, skyGrad;
function prerenderSprites() {
  pizzaSprite = document.createElement('canvas');
  pizzaSprite.width = 36; pizzaSprite.height = 36;
  const pc = pizzaSprite.getContext('2d');
  pc.font = '28px serif'; pc.textAlign = 'center'; pc.textBaseline = 'middle';
  pc.fillText('\u{1F355}', 18, 18);
  sushiSprite = document.createElement('canvas');
  sushiSprite.width = 36; sushiSprite.height = 36;
  const sc = sushiSprite.getContext('2d');
  sc.font = '28px serif'; sc.textAlign = 'center'; sc.textBaseline = 'middle';
  sc.fillText('\u{1F363}', 18, 18);
  skyGrad = ctx.createLinearGradient(0, 0, 0, H);
  skyGrad.addColorStop(0, '#060214');
  skyGrad.addColorStop(0.35, '#100822');
  skyGrad.addColorStop(0.7, '#1a0a2e');
  skyGrad.addColorStop(1, '#221040');
}

// Input
const keys = { left: false, right: false, jump: false };

// Keyboard
document.addEventListener('keydown', e => {
  if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = true;
  if (e.key === 'ArrowRight' || e.key === 'd') keys.right = true;
  if (e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') keys.jump = true;
});
document.addEventListener('keyup', e => {
  if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = false;
  if (e.key === 'ArrowRight' || e.key === 'd') keys.right = false;
  if (e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') keys.jump = false;
});

// Touch controls
function setupTouch(id, key) {
  const el = document.getElementById(id);
  el.addEventListener('touchstart', e => { e.preventDefault(); keys[key] = true; el.classList.add('active'); });
  el.addEventListener('touchend', e => { e.preventDefault(); keys[key] = false; el.classList.remove('active'); });
  el.addEventListener('touchcancel', e => { keys[key] = false; el.classList.remove('active'); });
}
setupTouch('btn-left', 'left');
setupTouch('btn-right', 'right');
setupTouch('btn-jump', 'jump');

let gameRunning = false;
let gameWon = false;
let animFrame = 0;

function recalcPlatforms() {
  // Recalc Y positions on resize
  H = canvas.height;
  const groundY = H - 40;
  platforms[0] = { x: 0, y: groundY, w: 600, h: 40 };
  platforms[1] = { x: 700, y: groundY, w: 400, h: 40 };
  platforms[2] = { x: 1200, y: groundY, w: 500, h: 40 };
  platforms[3] = { x: 1800, y: groundY, w: 400, h: 40 };
  platforms[4] = { x: 2300, y: groundY, w: 900, h: 40 };

  const floatingData = [
    [200, 140, 120], [450, 200, 120], [650, 160, 100],
    [880, 220, 130], [1100, 160, 110], [1350, 240, 140],
    [1550, 170, 100], [1750, 130, 120], [1950, 200, 130],
    [2150, 260, 120], [2400, 180, 140], [2650, 240, 130],
    [2900, 160, 120]
  ];
  for (let i = 0; i < floatingData.length; i++) {
    platforms[5 + i] = { x: floatingData[i][0], y: H - floatingData[i][1], w: floatingData[i][2], h: 20 };
  }

  // Collectibles Y
  const collectData = [
    [230, 180], [490, 240], [900, 260], [1370, 280], [1960, 240], [2670, 280],
    [670, 200], [1120, 200], [1570, 210], [2170, 300], [2420, 220], [2920, 200]
  ];
  for (let i = 0; i < collectibles.length; i++) {
    collectibles[i].x = collectData[i][0];
    collectibles[i].y = H - collectData[i][1];
  }
}

// ===================== INTRO DIALOGUE (Animal Crossing style) =====================
const dialogueLines = [
  "¬°Miau miau miau! üê±",
  "Hola... tengo algo muy\nimportante que decirte...",
  "¬°Pero primero necesito\ntu ayuda! üçïüç£",
  "Ay√∫dame a recoger todas\nlas pizzas y el sushi...",
  "¬°Y al final te dir√©\nmi secreto! üíï",
];
let dlgIndex = 0;
let dlgCharIndex = 0;
let dlgTyping = false;
let dlgDone = false;
let dlgMouthTimer = null;
let dlgTypeTimer = null;

function playMiaw() {
  ensureAudio();
  const freq = 700 + Math.random() * 500;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.connect(g); g.connect(audioCtx.destination);
  o.type = 'sine';
  o.frequency.setValueAtTime(freq, audioCtx.currentTime);
  o.frequency.linearRampToValueAtTime(freq * 0.8, audioCtx.currentTime + 0.07);
  g.gain.setValueAtTime(0.12, audioCtx.currentTime);
  g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.08);
  o.start(); o.stop(audioCtx.currentTime + 0.08);
}

function startDialogue() {
  ensureAudio();
  dlgIndex = 0;
  showDialogueLine();
}

function showDialogueLine() {
  if (dlgIndex >= dialogueLines.length) {
    launchGame();
    return;
  }
  const textEl = document.getElementById('dialogue-text');
  const hintEl = document.getElementById('continue-hint');
  const catEl = document.getElementById('intro-cat');
  textEl.textContent = '';
  hintEl.style.display = 'none';
  dlgCharIndex = 0;
  dlgTyping = true;
  dlgDone = false;

  const line = dialogueLines[dlgIndex];
  let mouthOpen = false;

  clearInterval(dlgTypeTimer);
  clearInterval(dlgMouthTimer);

  dlgTypeTimer = setInterval(() => {
    if (dlgCharIndex < line.length) {
      const ch = line[dlgCharIndex];
      textEl.textContent += ch;
      dlgCharIndex++;
      if (ch !== ' ' && ch !== '\n') playMiaw();
    } else {
      clearInterval(dlgTypeTimer);
      clearInterval(dlgMouthTimer);
      catEl.classList.remove('talking');
      dlgTyping = false;
      dlgDone = true;
      hintEl.style.display = 'inline';
    }
  }, 50);

  dlgMouthTimer = setInterval(() => {
    if (!dlgTyping) return;
    mouthOpen = !mouthOpen;
    if (mouthOpen) catEl.classList.add('talking');
    else catEl.classList.remove('talking');
  }, 100);
}

function advanceDialogue() {
  if (dlgTyping) {
    // Skip to end of current line
    clearInterval(dlgTypeTimer);
    clearInterval(dlgMouthTimer);
    const textEl = document.getElementById('dialogue-text');
    const hintEl = document.getElementById('continue-hint');
    const catEl = document.getElementById('intro-cat');
    textEl.textContent = dialogueLines[dlgIndex];
    catEl.classList.remove('talking');
    dlgTyping = false;
    dlgDone = true;
    hintEl.style.display = 'inline';
  } else if (dlgDone) {
    dlgIndex++;
    showDialogueLine();
  }
}

// Wire up start screen clicks/taps
document.getElementById('start-screen').addEventListener('click', () => {
  if (dlgIndex === 0 && dlgCharIndex === 0 && !dlgTyping) {
    startDialogue();
  } else {
    advanceDialogue();
  }
});

// Start showing the first dialogue prompt
setTimeout(() => { startDialogue(); }, 500);

function launchGame() {
  document.getElementById('start-screen').style.display = 'none';
  document.getElementById('hud').style.display = 'flex';
  document.getElementById('touch-controls').style.display = 'flex';
  recalcPlatforms();
  generateBuildings();
  prerenderSprites();
  cat.x = 80;
  cat.y = H - 120;
  cat.vx = 0;
  cat.vy = 0;
  gameRunning = true;
  updateHUD();
  gameLoop();
}

function updateHUD() {
  document.getElementById('hud-pizza').textContent = `üçï ${collectedPizza} / ${totalPizza}`;
  document.getElementById('hud-sushi').textContent = `üç£ ${collectedSushi} / ${totalSushi}`;
}

// ===================== DRAWING =====================
function drawCat(x, y, dir, frame) {
  const sx = x - cameraX;
  ctx.save();
  ctx.translate(sx + 20, y);
  if (dir < 0) ctx.scale(-1, 1);

  // Tail (behind body, curves up)
  const tw = Math.sin(frame * 0.1) * 8;
  ctx.strokeStyle = '#ee9933';
  ctx.lineWidth = 4;
  ctx.lineCap = 'round';
  ctx.beginPath();
  ctx.moveTo(-15, 15);
  ctx.quadraticCurveTo(-28, 5 + tw, -22, -8 + tw);
  ctx.stroke();

  // Body (horizontal oval - side profile)
  ctx.fillStyle = '#ffaa44';
  ctx.beginPath();
  ctx.ellipse(2, 16, 17, 12, 0, 0, Math.PI * 2);
  ctx.fill();

  // Stripes
  ctx.fillStyle = '#ee9933';
  ctx.fillRect(-7, 8, 3, 16);
  ctx.fillRect(-1, 8, 3, 16);
  ctx.fillRect(5, 8, 3, 16);

  // Legs (animated walk)
  const la = Math.sin(frame * 0.35) * 5;
  const mv = Math.abs(cat.vx) > 0;
  const a1 = cat.onGround && mv ? la : 0;
  const a2 = cat.onGround && mv ? -la : 0;
  ctx.fillStyle = '#ee9933';
  ctx.fillRect(-9, 24, 5, 12 + a1);
  ctx.fillRect(-1, 24, 5, 12 + a2);
  ctx.fillRect(7, 24, 5, 12 + a2);
  ctx.fillRect(15, 24, 5, 12 + a1);
  // Paws
  ctx.fillStyle = '#ffddbb';
  ctx.fillRect(-10, 35 + a1, 7, 3);
  ctx.fillRect(-2, 35 + a2, 7, 3);
  ctx.fillRect(6, 35 + a2, 7, 3);
  ctx.fillRect(14, 35 + a1, 7, 3);

  // Head (offset in movement direction)
  ctx.fillStyle = '#ffbb55';
  ctx.beginPath();
  ctx.arc(16, 2, 12, 0, Math.PI * 2);
  ctx.fill();

  // Far ear (behind head)
  ctx.fillStyle = '#ee9933';
  ctx.beginPath();
  ctx.moveTo(20, -6); ctx.lineTo(24, -20); ctx.lineTo(26, -6);
  ctx.fill();
  ctx.fillStyle = '#ffccbb';
  ctx.beginPath();
  ctx.moveTo(21, -7); ctx.lineTo(23, -17); ctx.lineTo(25, -7);
  ctx.fill();

  // Near ear
  ctx.fillStyle = '#ffaa44';
  ctx.beginPath();
  ctx.moveTo(10, -6); ctx.lineTo(8, -22); ctx.lineTo(16, -8);
  ctx.fill();
  ctx.fillStyle = '#ffccbb';
  ctx.beginPath();
  ctx.moveTo(11, -7); ctx.lineTo(10, -19); ctx.lineTo(15, -8);
  ctx.fill();

  // Eye (side profile - one visible)
  ctx.fillStyle = '#222';
  ctx.beginPath();
  ctx.ellipse(22, 0, 2.5, 3, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(23, -1, 1, 0, Math.PI * 2);
  ctx.fill();

  // Nose
  ctx.fillStyle = '#ff8899';
  ctx.beginPath();
  ctx.arc(27, 4, 2, 0, Math.PI * 2);
  ctx.fill();

  // Mouth
  ctx.strokeStyle = '#bb7744';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(27, 6);
  ctx.quadraticCurveTo(24, 9, 20, 7);
  ctx.stroke();

  // Whiskers (visible side only)
  ctx.strokeStyle = '#cc9955';
  ctx.lineWidth = 0.7;
  ctx.beginPath(); ctx.moveTo(26, 2); ctx.lineTo(38, -2); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(27, 4); ctx.lineTo(39, 3); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(27, 6); ctx.lineTo(38, 8); ctx.stroke();

  ctx.restore();
}

function drawPlatform(p) {
  const sx = p.x - cameraX;
  if (sx + p.w < -50 || sx > W + 50) return;

  if (p.h === 40) {
    // Ground
    ctx.fillStyle = '#2d1b4e';
    ctx.fillRect(sx, p.y, p.w, p.h);
    // Grass
    ctx.fillStyle = '#44cc77';
    ctx.fillRect(sx, p.y, p.w, 6);
    // Grass detail
    ctx.fillStyle = '#55dd88';
    for (let gx = sx; gx < sx + p.w; gx += 22) {
      ctx.beginPath();
      ctx.moveTo(gx, p.y);
      ctx.lineTo(gx + 5, p.y - 5);
      ctx.lineTo(gx + 10, p.y);
      ctx.fill();
    }
  } else {
    // Floating platform (solid fill, no gradient)
    ctx.fillStyle = '#ee6688';
    roundRect(ctx, sx, p.y, p.w, p.h, 6);
    ctx.fill();
    ctx.fillStyle = '#ff99bb';
    roundRect(ctx, sx + 3, p.y + 2, p.w - 6, 5, 3);
    ctx.fill();
  }
}

function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

function drawCollectible(c) {
  if (c.collected) return;
  const sx = c.x - cameraX;
  if (sx < -40 || sx > W + 40) return;
  const bob = Math.sin(animFrame * 0.05 + c.x) * 4;
  const sprite = c.type === 'pizza' ? pizzaSprite : sushiSprite;
  if (sprite) ctx.drawImage(sprite, sx - 18, c.y + bob - 18);
}

function drawBackground() {
  // Pre-rendered sky gradient (no createLinearGradient per frame)
  ctx.fillStyle = skyGrad || '#1a0a2e';
  ctx.fillRect(0, 0, W, H);

  // Stars (fast fillRect, no arc, no alpha string)
  ctx.fillStyle = '#fffff0';
  for (let i = 0; i < stars.length; i++) {
    const s = stars[i];
    const sx = ((s.x - cameraX * 0.15) % 2560 + 2560) % 2560;
    if (sx > W) continue;
    if ((animFrame + (s.b * 100 | 0)) % 120 < 15) continue;
    ctx.globalAlpha = 0.3 + s.b * 0.7;
    ctx.fillRect(sx, s.y, s.s, s.s);
  }
  ctx.globalAlpha = 1;
}

function drawCity() {
  for (let i = 0; i < buildings.length; i++) {
    const b = buildings[i];
    const sx = b.x - cameraX * 0.35;
    if (sx + b.w < -10 || sx > W + 10) continue;
    // Building body
    ctx.fillStyle = b.shade;
    ctx.fillRect(sx, b.y, b.w, H - b.y);
    // Top edge highlight
    ctx.fillStyle = 'rgba(255,255,255,0.04)';
    ctx.fillRect(sx, b.y, b.w, 2);
    ctx.fillStyle = 'rgba(255,255,255,0.02)';
    ctx.fillRect(sx, b.y, 1, H - b.y);

    if (b.msg) {
      drawMsgWins(b, sx);
    } else {
      const padX = ((b.w - b.wCols * 14) / 2) | 0;
      for (let r = 0; r < b.wRows; r++) {
        for (let c = 0; c < b.wCols; c++) {
          const lit = b.wins[r * b.wCols + c];
          ctx.fillStyle = lit ? '#ffdd55' : 'rgba(80,100,160,0.08)';
          ctx.fillRect(sx + padX + c * 14 + 2, b.y + 12 + r * 18, 10, 13);
          if (lit) {
            ctx.fillStyle = 'rgba(255,255,200,0.25)';
            ctx.fillRect(sx + padX + c * 14 + 4, b.y + 14 + r * 18, 6, 9);
          }
        }
      }
    }
  }
}

function drawMsgWins(b, sx) {
  const cs = b.cs;
  const ws = cs - 4;
  const padX = ((b.w - b.maxC * cs) / 2) | 0;
  const startY = b.y + 20;
  // Line 1: "TE AMO"
  const off1 = ((b.maxC - msgLine1[0].length) / 2) | 0;
  for (let r = 0; r < 5; r++) {
    for (let c = 0; c < msgLine1[0].length; c++) {
      const lit = msgLine1[r][c];
      ctx.fillStyle = lit ? '#ff69b4' : 'rgba(80,100,160,0.06)';
      ctx.fillRect(sx + padX + (off1 + c) * cs, startY + r * cs, ws, ws);
      if (lit) {
        ctx.fillStyle = 'rgba(255,105,180,0.3)';
        ctx.fillRect(sx + padX + (off1 + c) * cs + 2, startY + r * cs + 2, ws - 4, ws - 4);
      }
    }
  }
  // Line 2: "LOLA"
  const off2 = ((b.maxC - msgLine2[0].length) / 2) | 0;
  for (let r = 0; r < 5; r++) {
    for (let c = 0; c < msgLine2[0].length; c++) {
      const lit = msgLine2[r][c];
      ctx.fillStyle = lit ? '#ff69b4' : 'rgba(80,100,160,0.06)';
      ctx.fillRect(sx + padX + (off2 + c) * cs, startY + (r + 6) * cs, ws, ws);
      if (lit) {
        ctx.fillStyle = 'rgba(255,105,180,0.3)';
        ctx.fillRect(sx + padX + (off2 + c) * cs + 2, startY + (r + 6) * cs + 2, ws - 4, ws - 4);
      }
    }
  }
}

// ===================== GAME LOGIC =====================
let jumpPressed = false;

function update() {
  // Movement
  cat.vx = 0;
  if (keys.left) { cat.vx = -cat.speed; cat.dir = -1; }
  if (keys.right) { cat.vx = cat.speed; cat.dir = 1; }

  // Jump
  if (keys.jump && cat.onGround && !jumpPressed) {
    cat.vy = cat.jumpForce;
    cat.onGround = false;
    jumpPressed = true;
    playJump();
  }
  if (!keys.jump) jumpPressed = false;

  // Gravity
  cat.vy += GRAVITY;
  cat.x += cat.vx;
  cat.y += cat.vy;

  // Clamp X
  if (cat.x < 0) cat.x = 0;
  if (cat.x > WORLD_W - cat.w) cat.x = WORLD_W - cat.w;

  // Platform collision
  cat.onGround = false;
  for (const p of platforms) {
    if (
      cat.x + cat.w > p.x && cat.x < p.x + p.w &&
      cat.y + cat.h > p.y && cat.y + cat.h < p.y + p.h + cat.vy + 2 &&
      cat.vy >= 0
    ) {
      cat.y = p.y - cat.h;
      cat.vy = 0;
      cat.onGround = true;
    }
  }

  // Fall reset
  if (cat.y > H + 50) {
    cat.x = 80;
    cat.y = H - 120;
    cat.vx = 0;
    cat.vy = 0;
  }

  // Collectible collision
  for (const c of collectibles) {
    if (c.collected) continue;
    const dx = (cat.x + 20) - c.x;
    const dy = (cat.y + 20) - c.y;
    if (Math.sqrt(dx * dx + dy * dy) < 30) {
      c.collected = true;
      playCollect();
      if (c.type === 'pizza') collectedPizza++;
      else collectedSushi++;
      updateHUD();
    }
  }

  // Win check
  if (collectedPizza === totalPizza && collectedSushi === totalSushi && !gameWon) {
    gameWon = true;
    playWin();
    setTimeout(showProposal, 1500);
  }

  // Camera
  const targetCX = cat.x - W / 2 + 20;
  cameraX += (targetCX - cameraX) * 0.08;
  if (cameraX < 0) cameraX = 0;
  if (cameraX > WORLD_W - W) cameraX = WORLD_W - W;

  // Animation
  if (Math.abs(cat.vx) > 0) {
    cat.frameTimer++;
  }
  cat.frame = cat.frameTimer;
  animFrame++;
}

function draw() {
  drawBackground();
  drawCity();
  platforms.forEach(drawPlatform);
  collectibles.forEach(drawCollectible);
  drawCat(cat.x, cat.y, cat.dir, cat.frame);
}

function gameLoop() {
  if (!gameRunning) return;
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

// ===================== PROPOSAL LOGIC =====================
let noCount = 0;

function showProposal() {
  gameRunning = false;
  document.getElementById('touch-controls').style.display = 'none';
  document.getElementById('hud').style.display = 'none';
  document.getElementById('proposal-screen').style.display = 'flex';
  document.getElementById('btn-no').classList.remove('hidden');
  noCount = 0;
}

function answerYes() {
  playYes();
  document.getElementById('proposal-screen').style.display = 'none';
  document.getElementById('success-screen').style.display = 'flex';
  spawnFloatingHearts();
  startSuccessAnimation();
}

function answerNo() {
  noCount++;
  playError();
  document.getElementById('proposal-screen').style.display = 'none';
  document.getElementById('cat-message').style.display = 'flex';

  setTimeout(() => {
    document.getElementById('cat-message').style.display = 'none';
    document.getElementById('proposal-screen').style.display = 'flex';
    // Hide "No" button after first rejection
    document.getElementById('btn-no').classList.add('hidden');
  }, 2500);
}

function spawnFloatingHearts() {
  const container = document.body;
  const heartChars = ['üíñ', 'üíï', '‚ù§Ô∏è', 'üíó', 'üíì', 'ü©∑'];
  for (let i = 0; i < 30; i++) {
    const heart = document.createElement('div');
    heart.className = 'floating-heart';
    heart.textContent = heartChars[Math.floor(Math.random() * heartChars.length)];
    heart.style.left = Math.random() * 100 + '%';
    heart.style.fontSize = (Math.random() * 24 + 16) + 'px';
    heart.style.animationDuration = (Math.random() * 4 + 3) + 's';
    heart.style.animationDelay = (Math.random() * 5) + 's';
    container.appendChild(heart);
  }
}

// ===================== SUCCESS ANIMATION =====================
function startSuccessAnimation() {
  const sc = document.getElementById('success-canvas');
  const sctx = sc.getContext('2d');
  sc.width = window.innerWidth;
  sc.height = window.innerHeight;
  const SW = sc.width, SH = sc.height;

  // --- Fireworks ---
  const fireworks = [];
  const particles = [];
  const fwColors = ['#ff69b4','#ff1493','#ffb6c1','#ff6384','#ff4500','#ffd700','#00ffff','#7fff00','#ff00ff','#fff'];

  function spawnFirework() {
    fireworks.push({
      x: Math.random() * SW,
      y: SH,
      tx: SW * 0.15 + Math.random() * SW * 0.7,
      ty: SH * 0.08 + Math.random() * SH * 0.35,
      speed: 4 + Math.random() * 3,
      done: false
    });
  }

  function explode(x, y) {
    const count = 30 + Math.floor(Math.random() * 30);
    const color = fwColors[Math.floor(Math.random() * fwColors.length)];
    for (let i = 0; i < count; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 1 + Math.random() * 4;
      particles.push({
        x, y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: 60 + Math.random() * 40,
        maxLife: 100,
        color,
        size: 1.5 + Math.random() * 2
      });
    }
    // Pop sound
    ensureAudio();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.connect(g); g.connect(audioCtx.destination);
    o.type = 'sine';
    o.frequency.setValueAtTime(800 + Math.random() * 600, audioCtx.currentTime);
    o.frequency.linearRampToValueAtTime(200, audioCtx.currentTime + 0.15);
    g.gain.setValueAtTime(0.08, audioCtx.currentTime);
    g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.15);
    o.start(); o.stop(audioCtx.currentTime + 0.15);
  }

  // --- Cats ---
  const groundY = SH * 0.78;
  const catSize = 50;

  // Cat 1 (original cat - runs around excited)
  const cat1 = { x: SW * 0.3, y: groundY, dir: 1, frame: 0, phase: 'running', runTimer: 0 };
  // Cat 2 (glasses cat - waits on the right)
  const cat2 = { x: SW * 0.68, y: groundY };

  let kissing = false;
  let kissTimer = 0;
  let heartBursts = [];
  let sFrame = 0;
  let dragging1 = false, dragging2 = false;
  let dragOffX = 0, dragOffY = 0;
  let interactive = false; // true after kiss is done

  function drawSuccessCat(x, y, dir, frame, isGlasses) {
    sctx.save();
    sctx.translate(x, y);
    if (dir < 0) sctx.scale(-1, 1);

    const s = catSize / 40; // scale factor
    sctx.scale(s, s);

    // Tail
    const tw = Math.sin(frame * 0.15) * 8;
    sctx.strokeStyle = '#ee9933';
    sctx.lineWidth = 4;
    sctx.lineCap = 'round';
    sctx.beginPath();
    sctx.moveTo(-15, 15);
    sctx.quadraticCurveTo(-28, 5 + tw, -22, -8 + tw);
    sctx.stroke();

    // Body
    sctx.fillStyle = '#ffaa44';
    sctx.beginPath();
    sctx.ellipse(2, 16, 17, 12, 0, 0, Math.PI * 2);
    sctx.fill();

    // Stripes
    sctx.fillStyle = '#ee9933';
    sctx.fillRect(-7, 8, 3, 16);
    sctx.fillRect(-1, 8, 3, 16);
    sctx.fillRect(5, 8, 3, 16);

    // Legs
    const la = Math.sin(frame * 0.35) * 5;
    const mv = !kissing;
    const a1 = mv ? la : 0;
    const a2 = mv ? -la : 0;
    sctx.fillStyle = '#ee9933';
    sctx.fillRect(-9, 24, 5, 12 + a1);
    sctx.fillRect(-1, 24, 5, 12 + a2);
    sctx.fillRect(7, 24, 5, 12 + a2);
    sctx.fillRect(15, 24, 5, 12 + a1);
    // Paws
    sctx.fillStyle = '#ffddbb';
    sctx.fillRect(-10, 35 + a1, 7, 3);
    sctx.fillRect(-2, 35 + a2, 7, 3);
    sctx.fillRect(6, 35 + a2, 7, 3);
    sctx.fillRect(14, 35 + a1, 7, 3);

    // Head
    sctx.fillStyle = '#ffbb55';
    sctx.beginPath();
    sctx.arc(16, 2, 12, 0, Math.PI * 2);
    sctx.fill();

    // Far ear
    sctx.fillStyle = '#ee9933';
    sctx.beginPath();
    sctx.moveTo(20, -6); sctx.lineTo(24, -20); sctx.lineTo(26, -6);
    sctx.fill();
    sctx.fillStyle = '#ffccbb';
    sctx.beginPath();
    sctx.moveTo(21, -7); sctx.lineTo(23, -17); sctx.lineTo(25, -7);
    sctx.fill();

    // Near ear
    sctx.fillStyle = '#ffaa44';
    sctx.beginPath();
    sctx.moveTo(10, -6); sctx.lineTo(8, -22); sctx.lineTo(16, -8);
    sctx.fill();
    sctx.fillStyle = '#ffccbb';
    sctx.beginPath();
    sctx.moveTo(11, -7); sctx.lineTo(10, -19); sctx.lineTo(15, -8);
    sctx.fill();

    // Eye
    if (kissing) {
      // Closed happy eyes (^ ^)
      sctx.strokeStyle = '#222';
      sctx.lineWidth = 1.5;
      sctx.beginPath();
      sctx.arc(22, -1, 3, Math.PI, 0);
      sctx.stroke();
    } else {
      sctx.fillStyle = '#222';
      sctx.beginPath();
      sctx.ellipse(22, 0, 2.5, 3, 0, 0, Math.PI * 2);
      sctx.fill();
      sctx.fillStyle = '#fff';
      sctx.beginPath();
      sctx.arc(23, -1, 1, 0, Math.PI * 2);
      sctx.fill();
    }

    // Blush
    if (kissing || isGlasses) {
      sctx.fillStyle = 'rgba(255,150,150,0.35)';
      sctx.beginPath();
      sctx.ellipse(24, 5, 4, 2.5, 0, 0, Math.PI * 2);
      sctx.fill();
    }

    // Nose
    sctx.fillStyle = '#ff8899';
    sctx.beginPath();
    sctx.arc(27, 4, 2, 0, Math.PI * 2);
    sctx.fill();

    // Mouth
    sctx.strokeStyle = '#bb7744';
    sctx.lineWidth = 1;
    sctx.beginPath();
    sctx.moveTo(27, 6);
    sctx.quadraticCurveTo(24, 9, 20, 7);
    sctx.stroke();

    // Whiskers
    sctx.strokeStyle = '#cc9955';
    sctx.lineWidth = 0.7;
    sctx.beginPath(); sctx.moveTo(26, 2); sctx.lineTo(38, -2); sctx.stroke();
    sctx.beginPath(); sctx.moveTo(27, 4); sctx.lineTo(39, 3); sctx.stroke();
    sctx.beginPath(); sctx.moveTo(27, 6); sctx.lineTo(38, 8); sctx.stroke();

    // Glasses (for cat2)
    if (isGlasses) {
      sctx.strokeStyle = '#333';
      sctx.lineWidth = 1.8;
      // Left lens
      sctx.beginPath();
      sctx.arc(18, 0, 5, 0, Math.PI * 2);
      sctx.stroke();
      // Right lens
      sctx.beginPath();
      sctx.arc(27, 0, 5, 0, Math.PI * 2);
      sctx.stroke();
      // Bridge
      sctx.beginPath();
      sctx.moveTo(23, 0); sctx.lineTo(22, 0);
      sctx.stroke();
      // Arm
      sctx.beginPath();
      sctx.moveTo(13, 0); sctx.lineTo(6, -2);
      sctx.stroke();
      // Lens shine
      sctx.strokeStyle = 'rgba(255,255,255,0.4)';
      sctx.lineWidth = 1;
      sctx.beginPath();
      sctx.arc(17, -2, 2.5, -0.8, -0.2);
      sctx.stroke();
      sctx.beginPath();
      sctx.arc(26, -2, 2.5, -0.8, -0.2);
      sctx.stroke();

      // Glasses cat has a collar with a tiny heart
      sctx.fillStyle = '#ff69b4';
      sctx.beginPath();
      sctx.arc(8, 12, 3, 0, Math.PI * 2);
      sctx.fill();
      sctx.fillStyle = '#e0558e';
      sctx.beginPath();
      sctx.arc(8, 12, 1.8, 0, Math.PI * 2);
      sctx.fill();
    }

    sctx.restore();
  }

  // Kiss heart burst
  function spawnKissHearts() {
    const cx = (cat1.x + cat2.x) / 2;
    const cy = groundY - 20;
    for (let i = 0; i < 12; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 0.8 + Math.random() * 2;
      heartBursts.push({
        x: cx, y: cy,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed - 1.5,
        life: 80 + Math.random() * 40,
        size: 8 + Math.random() * 10
      });
    }
  }

  function drawHeart(x, y, size) {
    sctx.save();
    sctx.translate(x, y);
    const s = size / 16;
    sctx.scale(s, s);
    sctx.fillStyle = '#ff69b4';
    sctx.beginPath();
    sctx.moveTo(0, -4);
    sctx.bezierCurveTo(-8, -14, -16, -2, 0, 8);
    sctx.moveTo(0, -4);
    sctx.bezierCurveTo(8, -14, 16, -2, 0, 8);
    sctx.fill();
    sctx.restore();
  }

  // --- Animation loop ---
  let fwInterval = setInterval(spawnFirework, 400);
  let kissStarted = false;

  function successLoop() {
    sctx.clearRect(0, 0, SW, SH);

    // Night sky gradient
    const grad = sctx.createLinearGradient(0, 0, 0, SH);
    grad.addColorStop(0, '#060214');
    grad.addColorStop(0.5, '#1a0a2e');
    grad.addColorStop(1, '#2a1248');
    sctx.fillStyle = grad;
    sctx.fillRect(0, 0, SW, SH);

    // Ground
    sctx.fillStyle = '#2a1545';
    sctx.fillRect(0, groundY + catSize * 0.5, SW, SH);
    sctx.fillStyle = '#3a2060';
    sctx.fillRect(0, groundY + catSize * 0.5, SW, 3);

    // Update & draw fireworks trails
    for (let i = fireworks.length - 1; i >= 0; i--) {
      const fw = fireworks[i];
      const dx = fw.tx - fw.x, dy = fw.ty - fw.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < fw.speed) {
        explode(fw.tx, fw.ty);
        fireworks.splice(i, 1);
      } else {
        fw.x += (dx / dist) * fw.speed;
        fw.y += (dy / dist) * fw.speed;
        sctx.fillStyle = '#ffd700';
        sctx.fillRect(fw.x - 1.5, fw.y - 1.5, 3, 3);
        // Trail
        sctx.fillStyle = 'rgba(255,215,0,0.3)';
        sctx.fillRect(fw.x - 1, fw.y + 2, 2, 6);
      }
    }

    // Update & draw particles
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.03;
      p.vx *= 0.99;
      p.life--;
      if (p.life <= 0) { particles.splice(i, 1); continue; }
      sctx.globalAlpha = p.life / p.maxLife;
      sctx.fillStyle = p.color;
      sctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
    }
    sctx.globalAlpha = 1;

    // Cat 1 movement
    sFrame++;
    cat1.frame += 0.8;
    if (!kissing) {
      cat1.runTimer++;
      // Run back and forth excitedly
      const speed = 4;
      cat1.x += cat1.dir * speed;
      // Bounce at boundaries before kiss
      if (cat1.runTimer < 180) {
        if (cat1.x > SW * 0.6) cat1.dir = -1;
        if (cat1.x < SW * 0.15) cat1.dir = 1;
      } else {
        // After running, head toward cat2 for kiss
        if (!kissStarted) {
          kissStarted = true;
          cat1.dir = 1;
        }
        const target = cat2.x - catSize * 1.1;
        if (cat1.x < target) {
          cat1.x += 3;
          cat1.dir = 1;
        } else {
          cat1.x = target;
          kissing = true;
          kissTimer = 0;
          spawnKissHearts();
          clearInterval(fwInterval);
          // Final firework burst
          for (let i = 0; i < 5; i++) setTimeout(() => spawnFirework(), i * 200);
        }
      }
    } else {
      kissTimer++;
      if (kissTimer % 40 === 0 && kissTimer < 200) spawnKissHearts();
      if (kissTimer === 120 && !interactive) {
        interactive = true;
      }
    }

    // When interactive, allow dragging ‚Äî cats face each other
    if (interactive) {
      cat1.dir = cat1.x < cat2.x ? 1 : -1;
      cat2.dir = cat2.x < cat1.x ? 1 : -1;
    }

    // Draw cat 2 (glasses cat, facing left toward cat1)
    drawSuccessCat(cat2.x, cat2.y, interactive ? (cat2.dir || -1) : -1, sFrame, true);
    // Draw cat 1 (running/kissing)
    drawSuccessCat(cat1.x, cat1.y, interactive ? (cat1.dir || 1) : cat1.dir, cat1.frame, false);

    // Kiss indicator (heart between them)
    if (kissing) {
      const kx = (cat1.x + cat2.x) / 2;
      const ky = groundY - catSize * 0.6;
      const pulse = 1 + Math.sin(sFrame * 0.08) * 0.15;
      sctx.save();
      sctx.translate(kx, ky);
      sctx.scale(pulse, pulse);
      sctx.translate(-kx, -ky);
      drawHeart(kx, ky, 22);
      sctx.restore();
    }

    // Heart bursts
    for (let i = heartBursts.length - 1; i >= 0; i--) {
      const h = heartBursts[i];
      h.x += h.vx;
      h.y += h.vy;
      h.vy += 0.01;
      h.life--;
      if (h.life <= 0) { heartBursts.splice(i, 1); continue; }
      sctx.globalAlpha = h.life / 120;
      drawHeart(h.x, h.y, h.size);
    }
    sctx.globalAlpha = 1;

    // Hint to drag
    if (interactive) {
      sctx.globalAlpha = 0.4 + Math.sin(sFrame * 0.04) * 0.2;
      sctx.fillStyle = '#ffb6c1';
      sctx.font = '16px Segoe UI, Arial, sans-serif';
      sctx.textAlign = 'center';
      sctx.fillText('‚ú® Toca y mueve a los gatitos ‚ú®', SW / 2, SH - 30);
      sctx.globalAlpha = 1;
    }

    requestAnimationFrame(successLoop);
  }

  // --- Touch / Mouse drag handlers ---
  function getPos(e) {
    if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }
  function hitCat(cx, cy, px, py) {
    return Math.abs(px - cx) < catSize && Math.abs(py - cy) < catSize * 0.8;
  }
  function onDown(e) {
    if (!interactive) return;
    const p = getPos(e);
    if (hitCat(cat1.x, cat1.y, p.x, p.y)) {
      dragging1 = true; dragOffX = p.x - cat1.x; dragOffY = p.y - cat1.y;
      e.preventDefault();
    } else if (hitCat(cat2.x, cat2.y, p.x, p.y)) {
      dragging2 = true; dragOffX = p.x - cat2.x; dragOffY = p.y - cat2.y;
      e.preventDefault();
    }
  }
  function onMoveD(e) {
    if (!dragging1 && !dragging2) return;
    e.preventDefault();
    const p = getPos(e);
    if (dragging1) { cat1.x = p.x - dragOffX; cat1.y = p.y - dragOffY; }
    if (dragging2) { cat2.x = p.x - dragOffX; cat2.y = p.y - dragOffY; }
    // Spawn small hearts while dragging
    heartBursts.push({
      x: p.x, y: p.y - 20,
      vx: (Math.random() - 0.5) * 2, vy: -1 - Math.random(),
      life: 40, size: 6 + Math.random() * 6
    });
  }
  function onUp() { dragging1 = false; dragging2 = false; }

  sc.addEventListener('mousedown', onDown);
  sc.addEventListener('mousemove', onMoveD);
  sc.addEventListener('mouseup', onUp);
  sc.addEventListener('touchstart', onDown, { passive: false });
  sc.addEventListener('touchmove', onMoveD, { passive: false });
  sc.addEventListener('touchend', onUp);

  successLoop();
}

// Handle resize during game
window.addEventListener('resize', () => {
  resizeCanvas();
  if (gameRunning) {
    recalcPlatforms();
    generateBuildings();
    prerenderSprites();
  }
});
</script>
</body>
</html>